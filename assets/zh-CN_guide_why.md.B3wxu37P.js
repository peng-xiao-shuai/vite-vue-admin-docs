import{_ as t,c as d,O as o,o as c}from"./chunks/framework.CmyazEwt.js";const a="/vite-vue-admin-docs/bundler.png",i="/vite-vue-admin-docs/esm.png",b=JSON.parse('{"title":"为什么选择 Vite","description":"","frontmatter":{},"headers":[],"relativePath":"zh-CN/guide/why.md","filePath":"zh-CN/guide/why.md","lastUpdated":1728380874000}'),r={name:"zh-CN/guide/why.md"};function p(s,e,n,h,l,u){return c(),d("div",null,e[0]||(e[0]=[o('<h1 id="为什么选择-vite" tabindex="-1">为什么选择 Vite <a class="header-anchor" href="#为什么选择-vite" aria-label="Permalink to &quot;为什么选择 Vite&quot;">​</a></h1><p>如果你还不知道什么是 <code>Vite</code> 的话点击 <a href="https://vitejs.cn/" target="_blank" rel="noreferrer">这里</a>，快速了解。</p><h2 id="极速的启动" tabindex="-1">极速的启动 <a class="header-anchor" href="#极速的启动" aria-label="Permalink to &quot;极速的启动&quot;">​</a></h2><p><code>Vite</code> 非常非常快，对比 <code>Webpack(Vue-cli)</code>： 同等量代码（vue3 项目 15个组件、4个页面），不同构建工具执行的 dev 和 build 操作时长如下</p><div class="vp-table"><table><thead><tr><th>项目</th><th>dev 启动时长</th><th>dev 页面加载</th><th>build 时长</th></tr></thead><tbody><tr><td>vite</td><td>4834ms</td><td>537ms</td><td>7.26s</td></tr><tr><td>vue-cli</td><td>387ms</td><td>580ms</td><td>4.26s</td></tr></tbody></table></div><p><code>Vite</code> 和 <code>Webpack</code> 两者的 <code>dev</code> 命令运行耗时相差十几倍，理论上来说，项目越大性能差距越大。其中最大的原因是 <code>Vite</code> 在开发模式下并没有做太多打包操作。</p><p><code>Webpack</code> 启动后会做一堆事情，经历一条很长的编译打包链条，从入口开始需要逐步经历语法解析、依赖收集、代码转译、打包合并、代码优化，最终将高版本的、离散的源码编译打包成低版本、高兼容性的产物代码，这可满满都是 <code>CPU、IO</code> 操作啊，在 <code>Node</code> 运行时下性能必然是有问题。</p><p>而 <code>Vite</code> 以原生 <code>ESM</code> 方式服务源码。这实际上是让浏览器接管了打包程序的部分工作：<code>Vite</code> 只需要在浏览器请求源码时进行转换并按需提供源码。根据情景动态导入的代码，即只在当前屏幕上实际使用时才会被处理。</p><p><strong>基于打包器的开发服务器</strong><img src="'+a+'" alt="基于打包器的开发服务器"></p><p><strong>基于 ESM 的开发服务器</strong><img src="'+i+'" alt="基于 ESM 的开发服务器"></p><h2 id="快速的热重载" tabindex="-1">快速的热重载 <a class="header-anchor" href="#快速的热重载" aria-label="Permalink to &quot;快速的热重载&quot;">​</a></h2><p>同样也是模式的问题，热更新的时候，<code>Vite</code> 只需要立即编译当前所修改的文件即可，所以响应速度非常快。</p><p>而 <code>Webpack</code> 修改某个文件过后，会自动以这个文件为入口重写 <code>build</code> 一次，所有的涉及到的依赖也都会被加载一遍，所以反应速度会慢很多。</p><h2 id="对于-typescript-支持" tabindex="-1">对于 TypeScript 支持 <a class="header-anchor" href="#对于-typescript-支持" aria-label="Permalink to &quot;对于 TypeScript 支持&quot;">​</a></h2><p><code>Vite</code> 支持开箱即用地引入 <code>.ts</code> 文件。</p><p><code>Vite</code> 使用 <code>esbuild</code> 将 <code>TypeScript</code> 翻译到 <code>JavaScript</code>，约是 <code>tsc</code> 速度的 <code>20~30</code> 倍，同时 <code>HMR</code> 更新反映到浏览器的时间小于 <code>50ms。</code></p>',16)]))}const v=t(r,[["render",p]]);export{b as __pageData,v as default};
